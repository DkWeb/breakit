<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <script type="text/javascript" src="particle_explosion.js"></script>
        <script type="text/javascript" src="persistence.js"></script>
    </head>
    <body>
        <canvas id="myCanvas" width="800" height="600">            
        </canvas>

        <script>
            var ballX = 75;
            var ballY = 75;
            var ballSpeedX = 5;
            var ballSpeedY = 5;
            const PADDLE_WIDTH = 100;
            const PADDLE_THICKNESS = 10;
            const PADDLE_DIST_FROM_EDGE = 60;
            const BALL_RADIUS = 10;
            var paddleX = 400;
            var mouseX;
            var mouseY;
            const BRICK_COLS = 10;
            const BRICK_ROWS = 14;
            const BRICK_WIDTH = 80;
            const BRICK_HEIGHT = 20;
            const BRICK_GAP = 2;
            var brickGridStart = [ 
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            5, 3, 3, 3, 3, 3, 3, 3, 3, 5,
                            5, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                            5, 1, 1, 0, 0, 0, 0, 1, 1, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            5, 2, 2, 1, 0, 0, 1, 2, 2, 5,
                            3, 1, 1, 1, 0, 0, 1, 1, 1, 3
                            ];
            const BRICK_ID_TO_COLOR = {
                1: 'green',
                2: 'blue',
                3: 'yellow',
                5: 'red'
            }
            var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);                           
            // var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
            var bricksLeft;
            var points;
            var explosions = [];
            var canvas, canvasContext;
            const TEXT_FONT = '1.2em monospace';
            var waitingForPlayer = true;
            var listenerAdded = false;
            var currentHighscorePoints = 0;
            const HIGH_SCORE_SAVE_NAME = 'highscore';
            // One of 'INITIAL', 'PLAYING', 'HIGHSCORE'
            var gameState = 'INITIAL';

            window.onload = function() {
                canvas = document.getElementById('myCanvas');
                canvasContext = canvas.getContext('2d');
                var framesPerSecond = 30;
                setInterval(updateAll, 1000 / framesPerSecond);
                canvas.addEventListener('mousemove', updateMousePosition);

                function updateAll() {
                    if (gameState === 'INITIAL') {
                        if (!listenerAdded) {
                            objectStore.initStore('breakit', function() { 
                                objectStore.loadObject(HIGH_SCORE_SAVE_NAME, function(highscore) {
                                    if (highscore !== null && highscore !== undefined) {
                                        currentHighscorePoints = highscore.points;
                                    }
                                    drawStartScreenAndWaitForClick();
                                }, function() {
                                    console.log("Unable to load highscore. Skip highscore handling");
                                    currentHighscorePoints = Number.MAX_SAFE_INTEGER;                        
                                    drawStartScreenAndWaitForClick();
                                })
                            }, function() {
                                console.log("No indexdb possible on your system. Skip highscore handling");
                                currentHighscorePoints = Number.MAX_SAFE_INTEGER;
                                drawStartScreenAndWaitForClick();
                            }, function() {
                                console.log("You have probably disabled saving / loading functionality for this game. Skip highscore handling");
                                currentHighscorePoints = Number.MAX_SAFE_INTEGER;
                                drawStartScreenAndWaitForClick();
                            });
                        }
                        listenerAdded = true;
                    } else if (gameState === 'PLAYING') {
                        moveAll();
                        drawAll();
                    } else {
                        // gameState === 'HIGHSCORE'
                        if (!listenerAdded) {
                            if (points > currentHighscorePoints) {
                                currentHighscorePoints = points;
                                objectStore.saveObject({ "name": HIGH_SCORE_SAVE_NAME, "points": points}, drawHighscoreAndWaitForClick, function() {
                                    console.log("Saving highscore failed. Skip it!");
                                });
                            } else {
                                drawHighscoreAndWaitForClick();
                            }
                            listenerAdded = true;
                        }
                    }

                    function restartOnClick() {
                        waitingForPlayer = false;
                        listenerAdded = false;
                        window.removeEventListener("click", restartOnClick, false);   
                        gameState = 'PLAYING';
                        ballReset();
                        brickReset();
                        explosionsReset();
                    }

                    function drawHighscoreAndWaitForClick() {
                        window.addEventListener ('click', restartOnClick, false);
                        drawHighscore();
                        gameStart = false;
                    }

                    function drawStartScreenAndWaitForClick() {
                        window.addEventListener ('click', restartOnClick, false);
                        drawStartScreen();
                        gameStart = false;
                    }
                }

                function moveAll() {
                    ballMove();
                    ballBrickHandling();
                    ballPaddleHandling();
                    explosionsHandling();

                    function ballMove() {
                        ballX += ballSpeedX;
                        ballY += ballSpeedY;
                        if (ballX > canvas.width && ballSpeedX > 0.0 || 
                            ballX < 0 && ballSpeedX < 0.0) {
                            ballSpeedX *= -1;
                        }
                        if (ballY < 0 && ballSpeedY < 0.0) {
                            ballSpeedY *= -1;
                        }  

                        if (ballY > canvas.height) {
                            // Ball left bottom of the screen -> one round is over
                            gameState = 'HIGHSCORE';
                        }   
                    }

                    function ballBrickHandling() {
                        var ballBrickCol = Math.floor(ballX / BRICK_WIDTH);
                        var ballBrickRow = Math.floor(ballY / BRICK_HEIGHT);
                        var ballBrickIndex = colRowToArrayIndex(ballBrickCol, ballBrickRow);
                        // console.log("col " + ballBrickCol);
                        if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS && 
                            ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS &&
                            isBrickAtColRow(ballBrickCol, ballBrickRow)) {
                            explosions.push(particleGenerator.startExplosion(60, 100, ballX, ballY));
                            points += brickGrid[ballBrickIndex];
                            brickGrid[ballBrickIndex] = 0;
                            bricksLeft--;
                            var prevBallX = ballX - ballSpeedX;
                            var prevBallY = ballY - ballSpeedY;
                            var prevBrickCol = Math.floor(prevBallX / BRICK_WIDTH);
                            var prevBrickRow = Math.floor(prevBallY / BRICK_HEIGHT);
                            var handledCollision = false;
                            if (prevBrickCol !== ballBrickCol) {
                                var adjBrickSide = colRowToArrayIndex(prevBrickCol, ballBrickRow);
                                if (!isBrickAtColRow(prevBrickRow, ballBrickRow)) {
                                    ballSpeedX *= -1;
                                    handledCollision = true;
                                }
                            }
                            if (prevBrickRow !== ballBrickRow) {
                                if (!isBrickAtColRow(ballBrickCol, prevBrickRow)) {
                                    ballSpeedY *= -1;
                                    handledCollision = true;
                                }
                            }
                            if (!handledCollision) {
                                ballSpeedX *= -1;
                                ballSpeedY *= -1;
                            }
                        }
                    }

                    function ballPaddleHandling() {
                        var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
                        var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
                        var paddleLeftEdgeX = paddleX;
                        var paddleRightEdgeX = paddleX + PADDLE_WIDTH;

                        if ((ballY + BALL_RADIUS) > paddleTopEdgeY && ballY < paddleBottomEdgeY && 
                            ballX > paddleLeftEdgeX && ballX < paddleRightEdgeX) {
                            ballSpeedY *= -1;
                            var centerOfX = paddleLeftEdgeX + PADDLE_WIDTH / 2;
                            var distFromCenter = ballX - centerOfX;
                            // console.log(distFromCenter);
                            ballSpeedX = distFromCenter * 0.35;
                            
                            if (bricksLeft === 0) {
                                brickReset();
                            }
                        }
                    }

                    function explosionsHandling() {
                        if (explosions.length === 0) {
                            return;
                        }
                        var remainingExplosions = [];
                        for (var i = 0; i < explosions.length; i++) {
                            if (particleGenerator.updateNewFrame(explosions[i])) {
                                remainingExplosions.push(explosions[i]);
                            } 
                        }
                        explosions = remainingExplosions;
                    }
                }

                function drawAll() {                    
                    colorRect(0, 0, canvas.width, canvas.height, 'black');
                    drawBricks();
                    drawExplosions();
                    colorCircle(ballX, ballY, BALL_RADIUS, 'white');                    
                    colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');
                    // var mouseBrickCol = Math.floor(mouseX / BRICK_WIDTH);
                    // var mouseBrickRow = Math.floor(mouseY / BRICK_HEIGHT);
                    // var indexUnderMouse = colRowToArrayIndex(mouseBrickCol, mouseBrickRow);
                    //colorText(Math.floor(mouseBrickCol) + ',' + Math.floor(mouseBrickRow) + ':' + indexUnderMouse, mouseX, mouseY, 'yellow');
                    colorText("Left: " + bricksLeft, 10, 20, 'white');
                    colorText("Points:" + points, 700, 20, 'white')
                }

                function drawBricks() {
                    // Draw all bricks of the same color to avoid switching fillStyle to often -> slows down rendering otherwise
                    for (var brickId in BRICK_ID_TO_COLOR) {
                        if (BRICK_ID_TO_COLOR.hasOwnProperty(brickId)) {
                            canvasContext.fillStyle = BRICK_ID_TO_COLOR[brickId];
                            for (var r = 0; r < BRICK_ROWS; r++) {
                                for (var c = 0; c < BRICK_COLS; c++) {
                                    var brickTypeId = brickGrid[colRowToArrayIndex(c, r)];
                                    if (brickTypeId > 0 && brickId == brickTypeId) {
                                        colorRectWithoutChangeColor(BRICK_WIDTH * c, BRICK_HEIGHT * r, BRICK_WIDTH - BRICK_GAP, BRICK_HEIGHT - BRICK_GAP);
                                    }
                                }
                            }
                        }

                    }
                }

                function drawExplosions() {
                    for (var i = 0; i < explosions.length; i++) {
                        var explosion = explosions[i];
                        var color = calcRandomColorBetweenRGBAString(255, 0, 0, 1, 255, 255, 0, 0.8);
                        canvasContext.fillStyle = color;
                        for (var j = 0; j < explosion.particles.length; j++) {
                            var particle = explosion.particles[j];
                            colorRectWithoutChangeColor(particle.posX, particle.posY, 1, 1);
                        }
                    }
                }

                function drawHighscore() {
                    colorText("Existing Highscore: " + currentHighscorePoints, 330, 270, 'white');
                }

                function drawStartScreen() {
                    colorRect(0, 0, canvas.width, canvas.height, 'black');
                    colorText('Welcome to breakit. Click to start!', 250, 270, 'white');
                }

                function colorRect(topLeftX, topLeftY, width, height, fillColor) {
                    canvasContext.fillStyle = fillColor;
                    canvasContext.fillRect(~~(topLeftX), ~~(topLeftY), width, height);
                }


                function colorRectWithoutChangeColor(topLeftX, topLeftY, width, height) {
                    canvasContext.fillRect(~~(topLeftX), ~~(topLeftY), width, height);
                }                

                function colorCircle(centerX, centerY, radius, fillColor) {
                    canvasContext.fillStyle = fillColor;
                    canvasContext.beginPath();
                    canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
                    canvasContext.fill();
                }

                function colorText(text, textX, textY, fillColor) {
                    canvasContext.font = TEXT_FONT;
                    canvasContext.fillStyle = fillColor;
                    canvasContext.fillText(text, textX, textY);
                }

                function updateMousePosition(event) {
                    var rect = canvas.getBoundingClientRect();
                    var root = document.documentElement;
                    mouseX = event.clientX - rect.left - root.scrollLeft;
                    mouseY = event.clientY - rect.top - root.scrollTop;
                    paddleX = mouseX - PADDLE_WIDTH / 2;

                    // ballX = mouseX;
                    // ballY = mouseY;
                    // ballSpeedX = 4;
                    // ballSpeedY = -4;
                }

                function ballReset() {
                    ballX = canvas.width / 2;
                    ballY = canvas.height / 2;
                    // ballX = 30;
                    // ballY = 30;
                }

                function brickReset() {
                    bricksLeft = 0;
                    points = 0;
                    for (var i = 0; i < BRICK_COLS * BRICK_ROWS; i++) {
                        var startVal = brickGridStart[i];
                        brickGrid[i] = startVal;
                        if (startVal > 0) {
                            bricksLeft++;    
                        }
                    }
                }

                function explosionsReset() {
                    explosions = [];
                }
                
                function colRowToArrayIndex(col, row) {
                    return row * BRICK_COLS + col;
                }

                function isBrickAtColRow(col, row) {
                    if (col >= 0 && col < BRICK_COLS && 
                        row >= 0 && row < BRICK_ROWS) {
                            return brickGrid[colRowToArrayIndex(col, row)] > 0;
                    }
                    return false;
                }

                function calcRandomColorBetweenRGBAString(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var factor = Math.random();
                    var parts = [ ~~(r1 + factor * (r2 - r1)),  ~~(g1 + factor *(g2 - g1)), ~~(b1 + factor * (b2 - b1)), (a1 + factor * (a2 - a1)) ];
                    return 'rgba(' + parts.join(',') + ')';
                    // return 'rgba(' + Math.floor(r1 + factor * (r2 - r1)) + ',' + Math.floor(g1 + factor *(g2 - g1)) + ',' + Math.floor(b1 + factor * (b2 - b1)) + ',' + (a1 + factor * (a2 - a1)) + ')';
                }
            }
        </script>
    </body>
</html>